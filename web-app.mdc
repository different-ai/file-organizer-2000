---
description: How to implement web app components and features
globs: packages/web/**/*
---

# Web Application Implementation Guide

## Project Structure
All web application code should be created in `packages/web/`

## Key Components

### 1. API Routes
- Place all API routes in `packages/web/api/`
- Use Next.js API routes pattern
- Implement rate limiting for public endpoints
- Include proper error handling

### 2. Authentication
- Implement using Next.js Auth.js
- Store user sessions in database
- Handle token refresh flows

### 3. Database Integration
- Use Prisma as ORM
- Keep schema in `packages/web/prisma/`
- Follow migration best practices

### 4. Frontend Components
- Use React Server Components where possible
- Implement proper loading states
- Follow accessibility guidelines

## Vercel AI SDK Integration

### Setup
```typescript
import { StreamingTextResponse, LangChainStream } from 'ai'
import { ChatOpenAI } from 'langchain/chat_models/openai'
import { AIMessage, HumanMessage } from 'langchain/schema'
```

### API Route Implementation
```typescript
export async function POST(req: Request) {
  const { messages } = await req.json()
  const { stream, handlers } = LangChainStream()
  
  const llm = new ChatOpenAI({
    streaming: true,
    modelName: 'gpt-4-turbo-preview'
  })

  llm.call(
    messages.map((m: any) => 
      m.role === 'user' 
        ? new HumanMessage(m.content)
        : new AIMessage(m.content)
    ),
    {},
    [handlers]
  )

  return new StreamingTextResponse(stream)
}
```

### Frontend Usage
```typescript
'use client'
import { useChat } from 'ai/react'

export function Chat() {
  const { messages, input, handleInputChange, handleSubmit } = useChat()

  return (
    <div>
      {messages.map(m => (
        <div key={m.id}>{m.content}</div>
      ))}
      <form onSubmit={handleSubmit}>
        <input
          value={input}
          onChange={handleInputChange}
          placeholder="Say something..."
        />
      </form>
    </div>
  )
}
```

### Best Practices
1. Always implement proper error handling
2. Use streaming responses for better UX
3. Implement rate limiting
4. Cache responses when possible
5. Use environment variables for API keys
